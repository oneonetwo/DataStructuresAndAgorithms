## [图论算法]()

#### 目录
1. 图的定义
2. 存储方式
3. 图的遍历，
4. 应用 最短路，最小生成树。
### 一. 图的定义
1. 特点
- 图可以表示为一个点集和一个边集 Graph(V, E);
    - 1. 点的度数
        - 入度和出度：一个点相连的入边/出边的数量
    - 2. E-edge边
        - 有向和无向图
        - 带权图: 边的权值（长度）
    - 连通图，环
### 二. 存储方式
1. 邻接矩阵
2. 出边数组
3. 邻接表
### 三. 图的遍历
### 四. 应用
1. 求最短路
- **Bellman-ford 贝尔曼福特**
    - 基于动态规划和迭代的思想 O(n2m)
    - 思路
        - 1. 扫描所有边(x, y, z)，若dist[y]>dist[x]+z, 则用dist[x]+z 更新dist[y]
        - 2. 重复上述的步骤，直到没有更新操作发生
    - 若问题有解(图中没有负环)，bellman-ford “扫描所有边并更新”的过程至多执行n-1轮
        - 原因：一条最短路最多包含n-1条边
    - 可以把每一轮看做是DP的一个阶段
    - 第i轮至少已经求出包含边数不超过i的最短路
    - [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)
- **Dijstra 迪杰斯特拉**
    - 基于贪心思想，只适用于所有边的长度都是非负的图；
    - 思路：
        - 1. 初始化dist[k] = 0; 其余节点的dist的值为正无穷大。 初始化一个标记数组，用于记录已经访问过得节点 k为起始的节点编号
        - 2. 找出一个未被标记的、dist[x]最小的节点x, 然后标记节点x;
        - 3. 扫描节点x的所有出边(x,y,z),若dist[y]>dist[x]+z,则用dist[x]+z更新dist[y];
        - 4.重复上述2，3步骤，直到所有的节点都被标记
    - 用二叉堆维护最小dist值可以做到O(m*log(n))的时间复杂度。
    - [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)
- **Floyd 弗洛伊德**
    - 在O(n3)的时间内求出图中每一对点之间的最短路径
    - 1. 本质是动态规划算法
    - 2. dp[k, i, j]表示经过编号不超过k的点为中继，从i到j的最短路
        - 决策：是都使用K这个中继点 d[i, j] = min(d[i,j], d[i, k]+d[j, k]);
        - 初态：d为邻接矩阵（原始图的边的权值，不相连的边的初始值为+oo）;
    - [阈值距离内邻居最少的城市](https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)
2. 求最小生成树
- **kruskal 卡鲁斯卡尔**
    - 使用并查集维护无向图的最小生成森林 时间复杂度是O(mlogm);
    - 1. 建立并查集，各自点构成一个集合
    - 2. 把所有边按照权值从小到大排序，一次扫描每条边（x, y, z）
    - 3. 若x,y属于同一个集合（连通），则忽略这条边，继续扫描下一条
    - 4. 否则，合并x,y所在的集合，并且把 z 累加到答案中。
    - 5. 等所有的边都处理完成，处理过得边就是最小生成树
    - 模板题： [链接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)

    
